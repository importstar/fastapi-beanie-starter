"""
{{ pascal_case }} use case - business logic and data access
Simplified pattern using Beanie's built-in methods directly
"""

from datetime import datetime, timezone
from typing import Optional

from beanie import PydanticObjectId
from fastapi_pagination import Page
from fastapi_pagination.ext.beanie import paginate

from .model import {{ pascal_case }}
from .schemas import Create{{ pascal_case }}, Update{{ pascal_case }}, {{ pascal_case }}Response


class {{ pascal_case }}UseCase:
    """
    {{ pascal_case }} use case handling both business logic and data access.
    Uses Beanie Document methods directly for simplicity.
    """

    # ==================== Create Operations ====================

    async def create(self, data: Create{{ pascal_case }}) -> {{ pascal_case }}Response:
        """Create a new {{ feature_name }}"""
        {{ feature_name }} = {{ pascal_case }}(
            **data.model_dump(),
            created_at=datetime.now(timezone.utc),
        )

        await {{ feature_name }}.insert()
        return self._to_response({{ feature_name }})

    # ==================== Read Operations ====================

    async def get_by_id(self, {{ feature_name }}_id: str) -> Optional[{{ pascal_case }}Response]:
        """Get {{ feature_name }} by ID"""
        {{ feature_name }} = await {{ pascal_case }}.get(PydanticObjectId({{ feature_name }}_id))
        return self._to_response({{ feature_name }}) if {{ feature_name }} else None

    async def get_list(self) -> Page[{{ pascal_case }}Response]:
        """Get paginated list of {{ feature_name }}s"""
        find_query = {{ pascal_case }}.find_all().sort("-created_at")
        page = await paginate(find_query)
        return self._page_to_response(page)

    # ==================== Update Operations ====================

    async def update(self, {{ feature_name }}_id: str, data: Update{{ pascal_case }}) -> Optional[{{ pascal_case }}Response]:
        """Update {{ feature_name }} with validation"""
        {{ feature_name }} = await {{ pascal_case }}.get(PydanticObjectId({{ feature_name }}_id))
        if not {{ feature_name }}:
            return None

        update_data = data.model_dump(exclude_none=True)

        # Update fields
        for key, value in update_data.items():
            setattr({{ feature_name }}, key, value)

        {{ feature_name }}.updated_at = datetime.now(timezone.utc)
        await {{ feature_name }}.save()

        return self._to_response({{ feature_name }})

    # ==================== Delete Operations ====================

    async def delete(self, {{ feature_name }}_id: str) -> bool:
        """Delete {{ feature_name }} by ID"""
        {{ feature_name }} = await {{ pascal_case }}.get(PydanticObjectId({{ feature_name }}_id))
        if not {{ feature_name }}:
            return False

        await {{ feature_name }}.delete()
        return True

    # ==================== Private Helpers ====================

    def _to_response(self, {{ feature_name }}: {{ pascal_case }}) -> {{ pascal_case }}Response:
        """Convert {{ pascal_case }} model to {{ pascal_case }}Response"""
        return {{ pascal_case }}Response.model_validate({{ feature_name }}.model_dump())

    def _page_to_response(self, page: Page[{{ pascal_case }}]) -> Page[{{ pascal_case }}Response]:
        """Convert paginated {{ pascal_case }}s to paginated {{ pascal_case }}Response"""
        return Page(
            items=[self._to_response({{ feature_name }}) for {{ feature_name }} in page.items],
            total=page.total,
            page=page.page,
            size=page.size,
            pages=page.pages,
        )


# Dependency injection
def get_{{ feature_name }}_use_case() -> {{ pascal_case }}UseCase:
    """Get {{ pascal_case }}UseCase instance"""
    return {{ pascal_case }}UseCase()